<center><font size="6"><b>人工智能基础第一次实验</b></font></center>

<center><font size="3"><b>林文浩 PB21050974</b></font></center>

#### 一、A*

1. 本题中使用了曼哈顿距离，也就是两点之间x方向上距离加上y方向上距离，即d = |x2 - x1| + |y2 - y1|，显然，曼哈顿距离是从某个点到达终点在无视障碍情况下的最短距离，因此一定不会高估到达终点的代价，从而是admissible的；使用曼哈顿距离时，从任一点n点通过任意行动a到达后继节点n'，则代价为1，由几何关系易得出h(n) <= 1 + h(n')，这是因为这个移动要么是朝向（指的是移动方向夹角小于等于180°）终点P方向的，要么是背向的， 如果是朝向的，则h(n') = h(n) - 1，反之情况h(n') = h(n) + 1，无论哪种情况均满足h(n) <= c(n, a, n') + h(n')的情况，也就是说满足consistent。
2. 主要思路：设状态为(x,y,food)，当搜索中遇到补给站则food补满，否则food - 1，即使在同样的(x, y)，如果food不同，仍视为两个完全不同的节点，每次扩展节点时，将节点放入open_list和close_list，open_list表示搜索边缘上的节点，close_list表示已经搜索过或者已经在搜索边缘上，每次扩展时检查close_list，防止重复添加节点，由优先队列维护open_list，以遍每次获得g(h)最小的节点进行扩展。由于数据量较小，所以close_list使用了框架里默认的vector，但是其代价是O(n)，性能开销较大，如果数据较多，应该考虑将其改成哈希表。
3. 通过一个全局变量，每次扩展时增加 1，来代表其搜索开销。统计测试0~8的总开销，当使用曼哈顿距离作为启发式函数时，该值为452，如果使用0作为启发式函数，也就是一致代价搜索，则该值为570，可以看到确实A*较一致代价搜索有优化，这里看得不明显可能是因为数据量较小。

#### 二、Alpha-Beta剪枝

1. 算法过程：输入一个棋盘，然后对该棋盘递归调用该过程（alphaBeta）：该过程用于返回min或max值。初始状态alpha和beta分别为无限小和无限大，由该棋盘状态统计下一步能够进行的所有move放入一个vector中，如果当前是max层，则由轮流取出一个新的move构建子节点（新棋盘），对其调用alphaBeta，返回的是它的min，每次使用该返回的min来修改alpha（alpha取min的最大值）；反之如果是min层，则使用调用子节点返回的max来修改其beta。无论对于哪种情况，最终如果把所有子节点都遍历了一遍，则令alpha和beta相等。每次递归调用时层数减一，如果到了第0层，则说明搜索到底，使用棋盘评估函数来评估其得分，令其alpha和beta均等于这个值。如果有棋盘的将没了，说明棋局结束，同样需要直接返回而不能继续递归。最终得到一个的一个值即为最高的分数，通过该分数，从root节点正向往下寻找相应于最高分的alpha或beta值(取决于max还是min层)的子节点，即可还原整个棋局变化。以上还未进行alpha-beta剪枝，但是已经能够运行。当加入alpha-beta剪枝后，每次递归调用时，将父节点的alpha和beta传给子节点，如果是max层，当子节点的beta比父节点的alpha小时，后续的子节点已经不需要再检查，因为它不会影响到最终结果，因此可以剪掉，直接break，反之在min层，如果子节点的alpha已经大于父节点的beta，则剪枝。
2. 使用全局变量对alphaBeta的调用次数进行统计，以测试样例4，搜索3层为例，如果使用alpha-beta剪枝，则调用次数为6636，如果不剪枝，则为57125，可以发现优化的程度非常大，对于棋子数量较多的情况，如果不剪枝，跑四层搜索也要两分钟左右，跑五层根本跑不出，会爆内存，但是如果剪枝的话，四层只需要十秒左右，五层也能在三分钟之内跑出来。


